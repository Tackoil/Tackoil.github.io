import{_ as e,p as r,q as n,v as i,y as t,Q as p}from"./framework-1508a596.js";const o="/assets/mp_model-d9848c70.jpg",d="/assets/activfuc-d903051d.jpg",s="/assets/mlp-6ede06b2.png",l="/assets/sp-b24448cf.png",h="/assets/classify-9f854127.png",$="/assets/xorq-074a8bb1.png",a="/assets/2class-7131b759.png",c="/assets/mnist-f1afaa79.png",m="/assets/PER-de80e64d.png",g="/assets/andrst-dcb0e6dd.png",_="/assets/andrst2-2fc0a157.png",f="/assets/gd1-70c0f3ea.png",u="/assets/gd2-a3689fb1.png",b="/assets/eb-86f3aabe.png",x="/assets/dv-26038617.png",k="/assets/conv-e89f717a.gif",L="/assets/pool-c35cf303.png",w="/assets/cnn-281a2789.png",q="/assets/rnn-e54117b0.png",y="/assets/rnnlstm-8a4aaffb.png",E="/assets/resnet-fb28b87a.png",v={},N=t("p",null,"这个原本是通信网理论与应用这门课的一个调研型的大作业。（不过这个和通信网有什么关系）就当是笔者从零开始学习深度学习吧。",-1),z=t("p",null,"本篇BLOG含有大量的公式，用来阐明最基本的神经网络在优化问题的基本算法。此外根据查到的各种资料，本篇也会简单说明基于神经网络而发展的典型网络结构以及使用这些网络结构的领域。虽说含有大量的公式，不过用到的原理也只是最基本的高等数学。为了比较美观的展现公式和算法，还会使用一些基本的线性代数运算。",-1),S=t("p",null,"不过，毕竟初来乍到，可能有很多漏洞和疏忽之处，恳请理解指正。",-1),B=p('<h1 id="符号声明" tabindex="-1"><a class="header-anchor" href="#符号声明" aria-hidden="true">#</a> 符号声明</h1><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>$x_k^{(L)}$</td><td>第$L$层的第$k$个神经元的值</td></tr><tr><td>$w_{kn}^{(L)}$</td><td>第$L$层的第$k$个神经元与第$L-1$层的第$n$个神经元的连接权重</td></tr><tr><td>$\\theta_k^{(L)}$</td><td>第$L$层的第$k$个神经元的输入偏置</td></tr><tr><td>$z_k^{(L)}$</td><td>第$L$层的第$k$个神经元通过激活函数之前的值</td></tr><tr><td>$E$</td><td>误差</td></tr><tr><td>$\\hat{x}_k^{(L)}$</td><td>第$L$层的第$k$个神经元的估计值（通常指最后一层）</td></tr><tr><td>$N^{(L)}$</td><td>第$L$层的神经元的个数</td></tr></tbody></table><h1 id="参考与推荐阅读" tabindex="-1"><a class="header-anchor" href="#参考与推荐阅读" aria-hidden="true">#</a> 参考与推荐阅读</h1><p>本篇大部分内容参考自周志华的《机器学习》（西瓜书）和3Blue1Brown关于神经网络的视频。私心推荐一下3Blue1Brown这位作者的视频。</p><p>3Blue1Brown: <a href="https://youtu.be/aircAruvnKk" target="_blank" rel="noopener noreferrer">YouTube</a> <a href="https://space.bilibili.com/88461692" target="_blank" rel="noopener noreferrer">Bilibili</a></p><h1 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h1><h2 id="神经网络" tabindex="-1"><a class="header-anchor" href="#神经网络" aria-hidden="true">#</a> 神经网络</h2><blockquote><p>神经网络是由具有适应性的简单单元组成的广泛并行互联的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。</p></blockquote><p>上述概念来源于周志华在《机器学习》这本书中的对原论文的翻译。神经网络是由多个进行特定运算的单元组成的网络。</p><h2 id="m-p神经元模型" tabindex="-1"><a class="header-anchor" href="#m-p神经元模型" aria-hidden="true">#</a> m-p神经元模型</h2><p>上文提到论文中的神经元模型是含有<strong>时间</strong>这个参数的。在下面这张图中，忽略时间的影响得到神经元的结构。</p><p><img src="'+o+'" alt="M-P 神经元模型" title="M-P 神经元模型"></p><p>M-P神经元的数学模型为：</p><p>$$ \\begin{equation} y = f(\\sum_{k = 1}^{n} w_k x_k + \\theta) \\label{eq1} \\end{equation} $$</p><p>关于这张图上的模型，仍需几点特殊说明：</p><ul><li>对于一个神经元而言，这里$x$表示输入，$y$表示输出。而在多级神经网络中，$y$将表示下一级神经元的一个输入。</li><li>为了便于理解，在这里我们将输入和输出人为规定成0和1之间的数。在实际应用中不存在这样的限制。</li></ul><h2 id="激活函数" tabindex="-1"><a class="header-anchor" href="#激活函数" aria-hidden="true">#</a> 激活函数</h2><p>激活函数的出发点是将各个神经元的值限制在0到1之间，于是有<strong>单位阶跃函数</strong>和<strong>Sigmoid函数</strong>。随着这个限制的消失，追求更高收敛速度和性能的激活函数得以出现。例如<strong>ReLU函数</strong>、<strong>Softplus函数</strong>。</p><p>单位阶跃函数： $$ \\begin{equation} H(x) = \\begin{cases} 1, &amp; x \\geq 0 \\ 0, &amp; x &lt; 0 \\end{cases} \\end{equation} $$</p><p>Sigmoid函数： $$ \\begin{equation} \\mathrm{Sigmoid}(x) = \\frac{1}{1 + \\mathrm{e}^{-x}} \\end{equation} $$</p><p>ReLU函数： $$ \\begin{equation} \\mathrm{ReLU}(x) = \\begin{cases} x, &amp; x &gt; 0 \\ 0, &amp; x \\leq 0 \\end{cases} \\end{equation} $$</p><p>Softplus函数： $$ \\begin{equation} \\mathrm{Softplus}(x) = \\ln{(1 + \\mathrm{e}^{x})} \\end{equation} $$</p><p><img src="'+d+'" alt="激活函数" title="激活函数"></p><h2 id="多层前馈神经网络" tabindex="-1"><a class="header-anchor" href="#多层前馈神经网络" aria-hidden="true">#</a> 多层前馈神经网络</h2><p>这部分的公式会开始复杂起来，可以参考符号声明回顾各个符号的含义。</p><p>通常来说，一个基本的神经网络不会只有一层，而是由很多层构成的。我们把每个圆圈都当作可以存放数值的一个神经元，上一层神经元的数值会通过连线影响到下一层的数值。大概就像下面的这张图一样。通常我们把不是输入输出层的神经元称作<strong>隐含层</strong>。而<strong>输入层</strong>的值由输入向量完全决定，所以该层是所有层中最特殊的一层。我们把隐含层和输出层的神经元称作<strong>功能神经元</strong>。</p><p><img src="'+s+'" alt="多层感知机" title="多层感知机"></p><p>我们参考公式\\eqref{eq1}，更换符号和角标使得更加符合多层感知机的应用情况。</p><p>$$ \\begin{equation} x_{k}^{(L)} = f(\\sum_{n=0}^{N^{(L-1)}} w_{kn}^{(L-1)} x_n^{(L-1)} + \\theta_k^{(L)}) \\end{equation} $$</p><p>由此我们可以写出从第$L-1$层的各神经元的值计算第$L$层各神经元的值的公式。</p><p>$$ \\begin{equation} \\left[ \\begin{matrix} x_0^{(L)} \\ x_1^{(L)} \\ \\vdots \\ x_k^{(L)} \\end{matrix} \\right] = f \\left( \\left[ \\begin{matrix} w_{0,0}^{(L-1)} &amp; w_{0,1}^{(L-1)} &amp; \\cdots &amp; w_{0,n}^{(L-1)}\\ w_{1,0}^{(L-1)} &amp; w_{1,1}^{(L-1)} &amp; \\cdots &amp; w_{1,n}^{(L-1)}\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ w_{k,0}^{(L-1)} &amp; w_{k,1}^{(L-1)} &amp; \\cdots &amp; w_{k,n}^{(L-1)}\\ \\end{matrix} \\right] \\left[ \\begin{matrix} x_0^{(L-1)} \\ x_1^{(L-1)} \\ \\vdots \\ x_n^{(L-1)} \\end{matrix} \\right] + \\left[ \\begin{matrix} \\theta_0^{(L)} \\ \\theta_1^{(L)} \\ \\vdots \\ \\theta_k^{(L)} \\end{matrix} \\right] \\right) \\label{eq2} \\end{equation} $$</p><p>简化后就是:</p><p>$$ \\begin{equation} \\boldsymbol{x}^{(L)} = \\boldsymbol{f} \\left( \\mathbf{W}^{(L-1)} \\boldsymbol{x}^{(L-1)} + \\boldsymbol{\\theta}^{(L)} \\right) \\end{equation} $$</p><p>这个公式看起来就要美观不少。此外，该形式也比较容易使用<strong>numpy</strong>这种支持矩阵运算的插件来实现。</p><h1 id="应用环境" tabindex="-1"><a class="header-anchor" href="#应用环境" aria-hidden="true">#</a> 应用环境</h1><p>我们通过一些简单的例子，简单阐述一下这种神经网络结构可以用来做什么样的事情，以及网络复杂度与所解决问题的复杂度的相关性。</p><h2 id="简单的逻辑运算-与或非" tabindex="-1"><a class="header-anchor" href="#简单的逻辑运算-与或非" aria-hidden="true">#</a> 简单的逻辑运算（与或非）</h2><p>先看这个非常简单的例子。我们把这样的 “最小神经网络” 称作感知机：只有两个输入神经元和一个功能神经元。我们可以发现这样的感知机就可以搭建与或非门了。通过设定权值$w$和偏置$\\theta$就可以调整输出结果。（有了与或非是不是就可以用来搭计算机了x）</p><p><img src="'+l+'" alt="感知机的简单逻辑实现" title="感知机的简单逻辑实现"></p><h2 id="较复杂的逻辑运算-异或" tabindex="-1"><a class="header-anchor" href="#较复杂的逻辑运算-异或" aria-hidden="true">#</a> 较复杂的逻辑运算（异或）</h2><p>但在工程中，异或门使用的情况要远多于与或非门的使用情况。但实际上，异或问题无法通过上图的感知机模型实现。原因是简单的感知机在解决分类问题时，只能在二维平面画一条直线。而异或问题显然不能在二维平面内用一条线分开。</p><p><img src="'+h+'" alt="四种问题的空间分布情况" title="四种问题的空间分布情况"></p><p>看起来异或问题已经超出了简单的感知机的能力。那如何用神经网络实现异或问题呢？emm，再加一层。</p><p><img src="'+$+'" alt="异或问题的双层感知机" title="异或问题的双层感知机"></p><p>由此得知，通常来讲，问题越复杂，必要的神经元的个数和层数越多。</p><h2 id="再复杂一点的问题-简单的二分类问题" tabindex="-1"><a class="header-anchor" href="#再复杂一点的问题-简单的二分类问题" aria-hidden="true">#</a> 再复杂一点的问题（简单的二分类问题）</h2><p><img src="'+a+'" alt="简单的二分类问题" title="简单的二分类问题"></p><p>上面这个网络用来解决一个简单的二分类问题。即判断五个0~1的数字之和大于2.5还是小于2.5。（等于2.5？概率为零怕什么（不是））由于2.5这个结果分在任意一组均可，在之后描述该问题时，暂忽略该值。上面这个网络虽然可能不是最精简的网络，但可以完成这个分类问题，最简规模也应比异或问题要大很多。</p><h2 id="更复杂一点的问题-mnist数据集识别" tabindex="-1"><a class="header-anchor" href="#更复杂一点的问题-mnist数据集识别" aria-hidden="true">#</a> 更复杂一点的问题（MNIST数据集识别）</h2><p>这个就是很出名的有关于手写数字的数据集了。虽然目前有更好的解决办法，但这种普通的神经网络也可以解决这个问题。这个数据集中每一个数字都是由28*28像素构成的。图中这个网络结构由3Blue1Brown提出，不是最简单的方案但也可以完成数字分类的工作。但显然，这个更复杂的问题的解决方案，也需要更复杂的模型才可以解决。</p><blockquote><p>MNIST数据集：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener noreferrer">http://yann.lecun.com/exdb/mnist/</a></p></blockquote><p><img src="'+c+'" alt="MNIST分类问题" title="MNIST分类问题"></p><h1 id="实现方法" tabindex="-1"><a class="header-anchor" href="#实现方法" aria-hidden="true">#</a> 实现方法</h1><p>这部分会详细解释一下神经网络解决分类问题的基本流程，以及神经网络优化问题的数学模型以及解法。这部分会有大量的公式，但基本原理来自于高等数学<strong>导数的链式法则</strong>。</p><h2 id="神经网络优化问题的基本流程" tabindex="-1"><a class="header-anchor" href="#神经网络优化问题的基本流程" aria-hidden="true">#</a> 神经网络优化问题的基本流程</h2><p>感知机虽然只有一个功能神经元，不过也算是某种意义上的神经网络。先以感知机实现的<strong>与问题</strong>为例介绍下神经网络的优化问题是什么样子的。</p><p><img src="'+m+'" alt="感知机" title="感知机"></p><p>我们把感知机的模型再放在这里便于查看。然后定义模型:</p><p>$$ \\begin{equation} x_1 \\wedge x_2 \\quad y = f \\left( w_0 x_0 + w_1 x_1 + \\theta \\right) \\quad f(x) = \\mathrm{sgn}(x) \\end{equation} $$</p><p>我们的将按照下面的步骤完成这个优化问题：</p><ol><li>初始化$w_0$、$w_1$、$\\theta$</li><li>输入一组训练数据$x_0$、$x_1$得到输出$\\hat{y}$</li><li>根据该训练数据的标签计算，得到误差$E(y, \\hat{y})$</li><li>根据误差$E$调整$w_0$、$w_1$、$\\theta$</li></ol><h3 id="_1-初始化-w-0-、-w-1-、-theta" tabindex="-1"><a class="header-anchor" href="#_1-初始化-w-0-、-w-1-、-theta" aria-hidden="true">#</a> 1.初始化$w_0$、$w_1$、$\\theta$</h3><p>虽然说初始化对最终收敛得到的结果应该会有些影响，不过通常我们使用随机数据进行初始化。</p><p>$$w_0 = 0.3898 \\quad w_1 = 0.4950 \\quad \\theta = 0.8115$$</p><h3 id="_2-输入一组训练数据-x-0-、-x-1-得到输出-hat-y" tabindex="-1"><a class="header-anchor" href="#_2-输入一组训练数据-x-0-、-x-1-得到输出-hat-y" aria-hidden="true">#</a> 2.输入一组训练数据$x_0$、$x_1$得到输出$\\hat{y}$</h3><p>我们先选一组测试数据，比如：</p><p>$$(x_0, x_1), y = (1, 0), 0$$</p><p>然后根据公式\\eqref{eq1}计算得到估计值$\\hat{y}$。</p><p>$$ \\begin{aligned} \\hat{y} &amp; = \\mathrm{sgn} (0.3898 x_0 + 0.4950 x_1 + 0.8115) \\ \\hat{y} &amp; = \\mathrm{sgn} (0.3898 \\times 1 + 0.4950 \\times 0 + 0.8115) \\ &amp; = \\mathrm{sgn} (1.2013) \\ &amp; = 1 \\end{aligned} $$</p><h3 id="_3-根据该训练数据的标签计算-得到误差-e-y-hat-y" tabindex="-1"><a class="header-anchor" href="#_3-根据该训练数据的标签计算-得到误差-e-y-hat-y" aria-hidden="true">#</a> 3.根据该训练数据的标签计算，得到误差$E(y, \\hat{y})$</h3><p>接下来我们评价一下这个网络的输出结果。emm，显然与预期结果不符。这种不符合的程度，我们通过定义误差函数计算出实际结果与预期结果的差距。</p><p>$$ E(y, \\hat{y}) = y - \\hat{y} = 0 - 1 = -1 $$</p><h3 id="_4-根据误差-e-调整-w-0-、-w-1-、-theta" tabindex="-1"><a class="header-anchor" href="#_4-根据误差-e-调整-w-0-、-w-1-、-theta" aria-hidden="true">#</a> 4.根据误差$E$调整$w_0$、$w_1$、$\\theta$</h3><p>之后，我们根据这个误差，通过一定的方法更新我们的三个参数$w_0$、$w_1$、$\\theta$。通常，我们会控制一次学习改变的程度，从而使系统慢慢接近想要的结果。这里我们使用下面这种方法进行调整。</p><p>$$ w_i \\leftarrow w_i + \\eta E x_i \\quad \\eta \\in (0, 1) $$</p><p>我们把这里的$\\eta$称作学习率。因此我们按照这个公式完成对数据的调整。（关于$\\theta$的调整方式我们在后文详述。）</p><p>$$ \\begin{aligned} w_0 &amp; \\leftarrow 0.3898 + 0.1 \\times (-1) \\times 1 &amp; = 0.2898 \\ w_1 &amp; \\leftarrow 0.4950 + 0.1 \\times (-1) \\times 0 &amp; = 0.4950 \\ \\theta &amp; \\leftarrow 0.8115 + 0.1 \\times (-1) &amp; = 0.7115 \\end{aligned} $$</p><p>调整之后，我们就可以再返回步骤2，导入新的训练数据，对各个变量进行调整。下面这张图是笔者按照这种方式训练出来的结果，看起来还是很完美的实现了与门的功能。</p><p>$$ y = \\mathrm{sgn} ( 0.2898 x_0 + 0.1950 x_1 - 0.3885) $$</p><p><img src="'+g+'" alt="与门的训练结果1" title="与门的训练结果1"><img src="'+_+'" alt="与门的训练结果2" title="与门的训练结果2"></p><h2 id="神经网络优化问题的数学建模与算法" tabindex="-1"><a class="header-anchor" href="#神经网络优化问题的数学建模与算法" aria-hidden="true">#</a> 神经网络优化问题的数学建模与算法</h2><p>介绍完基本的流程，接下来的部分会详细的的介绍神经网络优化问题的数学模型，并如何对这个模型进行求解。当然，毕竟这是一个非常复杂的问题，可能无法准确的找到最优解，不过对于工业需求而言，总能在不断尝试中获得一个符合要求的结果。</p><p>我们以前面提到的简单的二分类问题为例，来进行下面的推导。首先，我们把前面这个问题的网络结构放在这里。</p><p><img src="'+a+'" alt="简单的二分类问题" title="简单的二分类问题"></p><p>我们希望在所有的训练例中，输出结果与预期结果尽可能的一致，也就是误差尽可能的小。所以这个问题的目标函数为：</p><p>$$ \\begin{equation} \\min_{w, \\theta}{E} \\label{eq:3} \\end{equation} $$</p><p>当然，定义$E$的方法各有不同，这里我们使用最常见的均方误差，所以公式\\eqref{eq:3}改写成：</p><p>$$ \\begin{equation} \\min_{w, \\theta}{E} = \\frac{1}{N} \\sum_{m=0}^{N - 1}{ \\left[ \\frac{1}{2} \\sum_{k}{\\left( \\hat{y}_k - y_k \\right)^2 } \\right]_m } \\end{equation} $$</p><p>这里的$m$指的是某一个训练例，$N$表示训练例的个数。</p><p>那接下来的问题就是，如何调整$w$，$\\theta$，使误差$E$最小。看起来这是一个<strong>无约束最小值问题</strong>。因此，这里可以求助于数学模型的相关知识，使用<strong>梯度下降法</strong>。</p><blockquote><h3 id="梯度下降法" tabindex="-1"><a class="header-anchor" href="#梯度下降法" aria-hidden="true">#</a> 梯度下降法</h3><p>梯度下降法是一个比较常见的用来解决无约束最小值问题的算法，<strong>但该算法无法保证所得结果为全局最小值</strong>。我们用下面这个简单的二次函数图像来说明梯度下降法。 <img src="'+f+'" alt="某个二次函数" title="某个二次函数"> 图中的曲线上的颜色表示该点出梯度的绝对值。梯度用来表征该点数值变化的最大值以及方向。因此利用梯度的这个性质，我们每次以梯度为参考，不断的向变化最大的方向<strong>下降</strong>，梯度的绝对值越大，下降的速度越大。当然这些都是比较定性的描述，下面我们用公式来描述这个算法。</p><p>首先确定目标函数: $$\\min_{x}{y} = x^2$$ 随机一个初始值，然后按照下面的策略不断更新参数$x$，使目标函数$y$达到最小。 $$ x \\leftarrow x + \\Delta x \\quad \\Delta x = - \\eta \\nabla y = - \\eta 2 x $$</p><table><thead><tr><th>序号</th><th>$x$</th><th>$y$</th><th>$\\delta x$</th></tr></thead><tbody><tr><td>1</td><td>$-3$</td><td>$9$</td><td>$0.6$</td></tr><tr><td>2</td><td>$-2.4$</td><td>$5.76$</td><td>$0.48$</td></tr><tr><td>3</td><td>$-1.92$</td><td>$3.686$</td><td>$0.384$</td></tr><tr><td>4</td><td>$-1.536$</td><td>$2.359$</td><td>$0.3072$</td></tr><tr><td>5</td><td>$-1.229$</td><td>$1.510$</td><td>$0.2458$</td></tr><tr><td>6</td><td>$-0.983$</td><td>$0.966$</td><td>$0.1966$</td></tr><tr><td>7</td><td>$-0.786$</td><td>$0.618$</td><td>$0.1258$</td></tr><tr><td>8</td><td>$-0.629$</td><td>$0.396$</td><td>$0.1006$</td></tr><tr><td>9</td><td>$\\cdots$</td><td>$\\cdots$</td><td>$\\cdots$</td></tr></tbody></table><p>根据表格内容发现，仅用了8次迭代就将结果的误差下降到$0.4$左右，可见这个算法还是有一定的效果的。但是，前文我们提到<strong>该算法无法保证所得结果为全局最小值</strong>，我们以下面的例子说明这一点。</p><p><img src="'+u+'" alt="某个四次函数" title="某个四次函数"></p><p>$$y = 0.25x^4 -0.1 x^3 - 3 x^2 - x + 0.5$$</p><p>我们仍以$x = -3$作为初始值，迭代100次，结果如下：</p><p>$$ x = -4.728182381361199 \\quad y = -2.3879650505567143 $$</p><p>显然，结果落入了局部最小值，而不是全局最小值。因此也提出了很多<strong>改善</strong>这一问题的方法，例如<em>模拟退火算法</em>等等，但本质上无法解决落入局部极小的问题。不过在工业上，局部极小的结果往往也足以满足需求，因此目前的优化算法都大体基于梯度下降法。</p></blockquote><p>由此，我们根据梯度下降算法，完成对神经网络里面各种参数的优化。反正求梯度就是求偏导嘛。首先我们列出各个参数与误差的函数关系。</p><p>$$ \\begin{equation} \\begin{aligned} E &amp; = \\frac{1}{2} \\sum_{k}(\\hat{x}^{(L)}_k - x^{(L)}_k)^2 \\ \\hat{x}^{(L)}_k &amp; = \\sigma(z^{(L)}_k) \\ z^{(L)}<em>k &amp; = w</em>{kn} x^{(L-1)}_n + \\theta^{(L)}_k \\end{aligned} \\end{equation} $$</p><p>然后开始求导。</p><p>$$ \\begin{equation} \\begin{aligned} \\frac{\\partial E}{\\partial w_{kn}} &amp;= \\frac{\\partial E}{\\partial x^{(L)}_k} \\cdot \\frac{\\partial x^{(L)}_k }{\\partial z^{(L)}<em>k} \\cdot \\frac{\\partial z^{(L)}<em>k}{\\partial w</em>{kn}} \\ \\frac{\\partial E}{\\partial \\theta^{(L)}</em>{k}} &amp;= \\frac{\\partial E}{\\partial x^{(L)}_k} \\cdot \\frac{\\partial x^{(L)}<em>k }{\\partial z^{(L)}<em>k} \\cdot \\frac{\\partial z^{(L)}<em>k}{\\partial \\theta^{(L)}</em>{kn}} \\ \\frac{\\partial E}{\\partial x^{(L-1)}</em>{n}} &amp;= \\sum</em>{k}{\\frac{\\partial E}{\\partial x^{(L)}_k} \\cdot \\frac{\\partial x^{(L)}_k }{\\partial z^{(L)}_k} \\cdot \\frac{\\partial z^{(L)}<em>k}{\\partial x^{(L-1)}</em>{n}} } \\end{aligned} \\end{equation} $$</p><p>观察上面的三个公式，发现其实就是普通的导数链式法则。但之所以拆解成这样的形式，是因为这样的形式可以被很方便的计算出来。</p><p>$$ \\begin{equation} \\begin{aligned} \\frac{\\partial E}{\\partial w_{kn}} &amp; = \\frac{\\partial E}{\\partial x^{(L)}_k} \\cdot \\frac{\\partial x^{(L)}_k }{\\partial z^{(L)}_k} \\cdot \\frac{\\partial z^{(L)}<em>k}{\\partial w</em>{kn}} &amp; = \\frac{\\partial E}{\\partial x^{(L)}<em>k} \\cdot \\sigma&#39;(z^{(L)}<em>k) \\cdot x^{(L-1)}</em>{n} \\ \\frac{\\partial E}{\\partial \\theta^{(L)}</em>{k}} &amp; = \\frac{\\partial E}{\\partial x^{(L)}_k} \\cdot \\frac{\\partial x^{(L)}_k }{\\partial z^{(L)}_k} \\cdot \\frac{\\partial z^{(L)}<em>k}{\\partial \\theta^{(L)}</em>{kn}} &amp; = \\frac{\\partial E}{\\partial x^{(L)}<em>k} \\cdot \\sigma&#39;(z^{(L)}<em>k) \\cdot 1 \\ \\frac{\\partial E}{\\partial x^{(L-1)}</em>{n}} &amp; = \\sum</em>{k} \\frac{\\partial E}{\\partial x^{(L)}_k} \\cdot \\frac{\\partial x^{(L)}_k }{\\partial z^{(L)}<em>k} \\cdot \\frac{\\partial z^{(L)}<em>k}{\\partial x^{(L-1)}</em>{n}} &amp; = \\sum</em>{k} \\frac{\\partial E}{\\partial x^{(L)}_k} \\cdot \\sigma&#39;(z^{(L)}<em>k) \\cdot w</em>{kn} \\ \\end{aligned} \\label{eq:4} \\end{equation} $$</p><p>最后一步，将公式\\eqref{eq:4}中的第三个公式代入第一个公式，就完成了第$L-1$与$L-2$层的误差传递。从而修改每一层的每一个参数，大功告成。</p><p>笔者根据以上的算法，完成了简单的二分类问题。基于Python的源码可以参见这个链接。</p><blockquote><p><a href="https://github.com/Tackoil/mlp_example" target="_blank" rel="noopener noreferrer">https://github.com/Tackoil/mlp_example</a></p></blockquote><p><img src="'+b+'" alt="简单二分类问题的实验结果" title="简单二分类问题的实验结果"></p><p>不过，这些算法最后都被TensorFlow或者pyTorch等等模块内置了，使用的时候只需要一句话就完成所有参数的调整，还是很方便的。</p><h1 id="相关技术" tabindex="-1"><a class="header-anchor" href="#相关技术" aria-hidden="true">#</a> 相关技术</h1><p>可喜可贺，最复杂的部分已经介绍完了，后面是一些现今针对这个简单的前馈神经网络的问题进行调整，得到一些新的性能更好的网络。</p><h2 id="多层前馈神经网络的不足" tabindex="-1"><a class="header-anchor" href="#多层前馈神经网络的不足" aria-hidden="true">#</a> 多层前馈神经网络的不足</h2><p>虽然这个模型可以解决很多很多复杂的无法提取特征的分类问题，但在应用过程中，发现还是有很多不足，也提出了很多针对某一个问题对该模型进行改进。</p><h3 id="运算量大" tabindex="-1"><a class="header-anchor" href="#运算量大" aria-hidden="true">#</a> 运算量大</h3><p>以我们刚刚得到的二分类问题这个模型为例，发现该模型一共使用了$92$个变量。需要计算$78$次浮点数乘法。这远比计算$4$次浮点数加法要复杂得多。再加上上万的训练数据，无疑是一个巨大的负担。</p><p>针对这一问题，人们提出了很多模型简化的方案，提高系统的效率。目前最常见的方案称作<strong>权值共享</strong>。当然不能随意选择哪些部分权值相等，通常人们将具有一定相关性的节点选择相同的权值。这也是<strong>卷积神经网络</strong>的一个出发点。</p><h3 id="输入节点固定" tabindex="-1"><a class="header-anchor" href="#输入节点固定" aria-hidden="true">#</a> 输入节点固定</h3><p>可以发现，这个系统输入点数是固定的。训练好的系统无法对与输入长度不符的数据进行分类。另外，即使在末位补零与输入长度匹配效果也不是很理想。于是提出<strong>循环神经网络</strong>，将时间参数引入神经元模型，这样就可以输入不定长的数据，解决序列相关的问题。</p><h3 id="梯度弥散与梯度爆炸" tabindex="-1"><a class="header-anchor" href="#梯度弥散与梯度爆炸" aria-hidden="true">#</a> 梯度弥散与梯度爆炸</h3><p>首先，我们简单计算一下各层对权重的偏导$\\frac{\\partial E}{\\partial w}$</p><p>$$ \\begin{equation} \\begin{aligned} \\frac{\\partial E}{\\partial w_{kn}} &amp;= \\frac{\\partial E}{\\partial x_k^{(L)}} \\cdot \\sigma&#39; (z_k^{(L)}) \\cdot x_n^{(L-1)} \\ \\frac{\\partial E}{\\partial w_{nj}} &amp;= \\sum_k \\left( \\frac{\\partial E}{\\partial x_k^{(L)}} \\cdot \\sigma&#39; (z_k^{(L)}) \\cdot w_{kn} \\right) \\cdot \\sigma&#39; (z_n^{(L-1)}) \\cdot x_j^{(L-2)} \\ \\frac{\\partial E}{\\partial w_{ji}} &amp;= \\sum_n \\left( \\sum_k \\left( \\frac{\\partial E}{\\partial x_k^{(L)}} \\cdot \\sigma&#39; (z_k^{(L)}) \\cdot w_{kn} \\right) \\cdot \\sigma&#39; (z_n^{(L-1)}) \\cdot w_{nj} \\right) \\cdot \\sigma&#39; (z_j^{(L-2)}) \\cdot x_i^{(L-3)} \\ \\end{aligned} \\end{equation} $$</p><p>可以发现，这个偏导数里面有激活函数导数的三次幂。可见当层数越多时，激活函数的导数对系统的影响越大。那我们来看一下$\\mathrm{Sigmoid}(x)$的导数，可见其函数值最大值在$0.25$左右。随着系统层数的增加，梯度值会越来越小，导致首层的神经元基本无法得到优化。我们把这种现象称作<strong>梯度弥散</strong>。相对的，导数值基本大于$1$，从而使首层收到的梯度值异常的大，把这种称作<strong>梯度爆炸</strong>。</p><p><img src="'+x+'" alt="Sigmoid(x)的导数" title="Sigmoid(x)的导数"></p><h2 id="卷积神经网络与模型压缩" tabindex="-1"><a class="header-anchor" href="#卷积神经网络与模型压缩" aria-hidden="true">#</a> 卷积神经网络与模型压缩</h2><p>卷积神经网络主要使用了权值共享从而大步幅降低运算量。当然，也充分利用了图像数据的相关性，使相邻的一部分像素共享相同的权值。为了使权值共享带来的负效应尽可能的小，这个网络也对神经网络的运算做了适当的修改，但也基本符合之前的结论。该模型被广泛的使用在计算机视觉领域。（多半也是因为视觉相关的图像数据内相关性很高）</p><p>卷积神经网络主要有两种比较特殊的层。通常我们把他们称作<strong>卷积层</strong>与<strong>池化层</strong>。</p><p>卷积层所做的如下图所示，对原始数据进行窗口滑动，与权值矩阵对应位置相乘再相加，得到一个数据，作为输出结果。下面这个图比较生动的说明了卷积层的功能。也推荐这个网页关于卷积层的动态展示。（不过这哪里卷积了x）</p><blockquote><p><a href="http://cs231n.github.io/assets/conv-demo/index.html" target="_blank" rel="noopener noreferrer">http://cs231n.github.io/assets/conv-demo/index.html</a></p></blockquote><p><img src="'+k+'" alt="卷积层" title="卷积层"></p><p><img src="'+L+'" alt="池化层" title="池化层"></p><p>为了简化说明，我们把卷积层与池化层作为一个神经元。以这个著名的手写数字识别的模型为例，发现其功能神经元的第一层只使用了6个神经元，第二层使用了10个神经元。每两个神经元的连接由原来的乘法变成了卷积+池化。从而大幅度的减少系统的运算量。</p><p><img src="'+w+'" alt="卷积神经网络与另一种表示方式" title="卷积神经网络与另一种表示方式"></p><p>但为了满足移动设备的需要，当前的模型仍然过于复杂。Google的相关团队 与 旷视的Face++团队分别提出了MobileNets和ShuffleNet进行进一步的模型压缩。</p><blockquote><p>MobileNets：<a href="https://arxiv.org/abs/1704.04861v1" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1704.04861v1</a> ShuffleNet：<a href="https://arxiv.org/abs/1707.01083v2" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1707.01083v2</a></p></blockquote><h2 id="循环神经网络与长短期记忆网络" tabindex="-1"><a class="header-anchor" href="#循环神经网络与长短期记忆网络" aria-hidden="true">#</a> 循环神经网络与长短期记忆网络</h2><p>为了解决输入数据无法改变长度问题，于是引入循环神经网络。一般来说，对于输入到循环神经网络的一个元素而言，其输入到输出只有三层。但网络隐含层的状态会随着循环次数不断变化。这样就被称作循环神经网络了。该网络经常使用在语音处理，自然语音处理等等。</p><p><img src="'+q+'" alt="循环神经网络" title="循环神经网络"></p><p>不过，这个模型的梯度弥散问题非常严重。于是进一步引入每个神经元的遗忘系统，得到长短期记忆网络。因为变量增多，系统也看着更加复杂起来。</p><p><img src="'+y+'" alt="循环神经网络与长短期记忆网络" title="循环神经网络与长短期记忆网络"></p><h2 id="残差神经网络" tabindex="-1"><a class="header-anchor" href="#残差神经网络" aria-hidden="true">#</a> 残差神经网络</h2><p>为了解决梯度弥散与梯度爆炸的问题，这个模型只做了一点点简单的修改，却得到了出乎意料的效果。详情可以参考这篇提出残差神经网络的论文。</p><blockquote><p>ResNet: <a href="https://arxiv.org/abs/1512.03385v1" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1512.03385v1l</a></p></blockquote><p><img src="'+E+'" alt="残差神经网络" title="残差神经网络"></p><h1 id="special-thanks" tabindex="-1"><a class="header-anchor" href="#special-thanks" aria-hidden="true">#</a> Special Thanks</h1><p>在此感谢为这次调研提供帮助的各位。也感谢オレンジ提供的帮助与校对~~~</p><ul><li>Johntheuser</li><li>オレンジ</li><li>Tab</li></ul><h1 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h1><ul><li>Kohonen, Teuvo . An introduction to neural computing. Neural Networks 1.1(1988):3-16</li><li>But what <em>is</em> a Neural Network? | Deep learning, Part 1 3Blue1Brown <a href="https://youtu.be/aircAruvnKk" target="_blank" rel="noopener noreferrer">https://youtu.be/aircAruvnKk</a></li><li>THE MNIST DATABASE of handwritten digits Yann LeCun, Corinna Cortes, Christopher J.C. Burges <a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener noreferrer">http://yann.lecun.com/exdb/mnist/</a></li><li>使用Python将MNIST数据集转化为图片 name_s_Jimmy <a href="https://blog.csdn.net/qq_32166627/article/details/52640730" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_32166627/article/details/52640730</a></li><li>Lécun, Y., Bottou, L., Bengio, Y., &amp; Haffner, P. (1998). learning applied to document recognition. Proceedings of the IEEE, 86(11), 2278-2324. Gradient-based</li><li>刘建平Pinard, 卷积神经网络(CNN)模型结构 <a href="https://www.cnblogs.com/pinard/p/6483207.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/pinard/p/6483207.html</a></li><li>蒋竺波, CNN入门讲解：什么是采样层（pooling） <a href="https://zhuanlan.zhihu.com/p/32299939" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/32299939</a></li><li>刘建平Pinard,循环神经网络(RNN)模型与前向反向传播算法 <a href="https://www.cnblogs.com/pinard/p/6509630.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/pinard/p/6509630.html</a></li><li>刘建平Pinard, LSTM模型与前向反向传播算法 <a href="https://www.cnblogs.com/pinard/p/6519110.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/pinard/p/6519110.html</a></li><li>Howard, A. G. , Zhu, M. , Chen, B. , Kalenichenko, D. , Wang, W. , &amp; Weyand, T. , et al. (2017). Mobilenets: efficient convolutional neural networks for mobile vision applications.</li><li>Zhang, X. , Zhou, X. , Lin, M. , &amp; Sun, J. . (2017). Shufflenet: an extremely efficient convolutional neural network for mobile devices.</li><li>He, K. , Zhang, X. , Ren, S. , &amp; Sun, J. . (2015). Deep residual learning for image recognition.</li><li>周志华. (2016). 机器学习. 清华大学出版社.</li></ul>',141);function T(M,P){return r(),n("div",null,[N,z,S,i(" more "),B])}const A=e(v,[["render",T],["__file","nn0.html.vue"]]);export{A as default};
